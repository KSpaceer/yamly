package generator

import (
	"bytes"
	"fmt"
	"io"
	"reflect"
	"slices"
)

const (
	pkgYAYAMLS = "github.com/KSpaceer/yayamls"
	pkgDecode  = "github.com/KSpaceer/yayamls/decode"
	pkgEncode  = "github.com/KSpaceer/yayamls/encode"
)

type Generator struct {
	out *bytes.Buffer

	outputFile string
	pkgName    string
	pkgPath    string

	buildTags              string
	omitempty              bool
	disallowUnknownFields  bool
	marshalPointerReceiver bool

	imports map[string]string

	targetType reflect.Type

	pendingTypes   []reflect.Type
	generatedTypes map[reflect.Type]bool

	funcNames map[string]reflect.Type
}

func New(outputFile string) *Generator {
	return &Generator{
		outputFile: outputFile,
		imports: map[string]string{
			pkgYAYAMLS: "yayamls",
			pkgDecode:  "decode",
			pkgEncode:  "encode",
		},
		generatedTypes: make(map[reflect.Type]bool),
		funcNames:      make(map[string]reflect.Type),
	}
}

func (g *Generator) SetPkgName(pkgName string) {
	g.pkgName = pkgName
}

func (g *Generator) SetPkgPath(pkgPath string) {
	g.pkgPath = pkgPath
}

func (g *Generator) SetBuildTags(buildTags string) {
	g.buildTags = buildTags
}

func (g *Generator) SetOmitempty(omitempty bool) {
	g.omitempty = omitempty
}

func (g *Generator) SetDisallowUnknownFields(disallow bool) {
	g.disallowUnknownFields = disallow
}

func (g *Generator) SetMarshalPointerReceiver(useReceiver bool) {
	g.marshalPointerReceiver = useReceiver
}

func (g *Generator) AddType(v any) {
	t := reflect.TypeOf(v)
	if t.Kind() == reflect.Pointer {
		t = t.Elem()
	}
	g.addType(t)
	g.targetType = t
}

func (g *Generator) addType(t reflect.Type) {
	if g.generatedTypes[t] {
		return
	}
	for _, pendingType := range g.pendingTypes {
		if pendingType == t {
			return
		}
	}
	g.pendingTypes = append(g.pendingTypes, t)
}

func (g *Generator) Generate(w io.Writer) error {
	g.out = &bytes.Buffer{}

	g.generateHeader()
	for len(g.pendingTypes) > 0 {
		t := g.pendingTypes[len(g.pendingTypes)-1]
		g.pendingTypes = g.pendingTypes[:len(g.pendingTypes)-1]
		g.generatedTypes[t] = true

		if err := g.generateDecoder(t); err != nil {
			return err
		}

		if err := g.generateEncoder(t); err != nil {
			return err
		}

		if t != g.targetType {
			continue
		}

		if err := g.generateUnmarshaler(t); err != nil {
			return err
		}

		if err := g.generateMarshaler(t); err != nil {
			return err
		}
	}
	_, err := w.Write(g.out.Bytes())
	return err
}

func (g *Generator) generateHeader() {
	if g.buildTags != "" {
		fmt.Fprintln(g.out, "// +build ", g.buildTags)
		fmt.Fprintln(g.out)
	}
	fmt.Fprintln(g.out, "// Code generated by yayamls. DO NOT EDIT.")
	fmt.Fprintln(g.out)
	fmt.Fprintln(g.out, "package", g.pkgName)
	fmt.Fprintln(g.out)

	byAlias := make(map[string]string, len(g.imports))
	aliases := make([]string, 0, len(g.imports))

	for path, alias := range g.imports {
		aliases = append(aliases, alias)
		byAlias[alias] = path
	}

	slices.Sort(aliases)
	fmt.Fprintln(g.out, "import (")
	for _, alias := range aliases {
		fmt.Fprintf(g.out, "  %s %q\n", alias, byAlias[alias])
	}
	fmt.Fprintln(g.out, ")")
	fmt.Fprintln(g.out)
	fmt.Fprintln(g.out, "// suppress unused package warning")
	fmt.Fprintln(g.out, "var (")
	fmt.Fprintln(g.out, "  _ yayamls.Marshaler")
	fmt.Fprintln(g.out, "  _ *encode.ASTWriter")
	fmt.Fprintln(g.out, "  _ *decode.ASTReader")
	fmt.Fprintln(g.out, ")")

	fmt.Fprintln(g.out)
}
