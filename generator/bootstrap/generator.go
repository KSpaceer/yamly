// Package bootstrap contains generator for bootstrap main
// with actual generating with generator.Generator
package bootstrap

import (
	"fmt"
	"go/format"
	"os"
	"os/exec"
	"path/filepath"
)

const generatorPackage = "github.com/KSpaceer/yamly/generator"

// Generator is used to generate a temporary bootstrap file in target package
// with actual generator.Generator to generate the actual code.
type Generator struct {
	PkgPath string
	PkgName string
	Type    string

	Omitempty             bool
	DisallowUnknownFields bool

	EncodePointerReceiver bool
	InlineEmbedded        bool

	EngineGeneratorPackage string
	EngineGenerator        string

	OutputName string
	BuildTags  string
}

func (g *Generator) generateStub() error {
	f, err := os.Create(g.OutputName)
	if err != nil {
		return err
	}
	defer f.Close()

	if g.BuildTags != "" {
		// using old syntax because it supports comma-separated tags
		fmt.Fprintln(f, "// +build ", g.BuildTags)
		fmt.Fprintln(f)
	}
	fmt.Fprintln(f, "// TEMPORARY AUTOGENERATED FILE: yamly stub code to compile the generator")
	fmt.Fprintln(f)
	fmt.Fprintln(f, "package ", g.PkgName)
	fmt.Fprintln(f)

	var marshallableType string
	if g.EncodePointerReceiver {
		marshallableType = "*" + g.Type
	} else {
		marshallableType = g.Type
	}

	fmt.Fprintln(f, "func (", marshallableType, ") MarshalYAML() ([]byte, error) { return nil, nil }")
	fmt.Fprintln(f, "func (*", g.Type, ") UnmarshalYAML([]byte) error { return nil }")
	fmt.Fprintln(f)
	fmt.Fprintln(f, "type Exporter_yamly_"+g.Type+" *"+g.Type)
	return nil
}

func (g *Generator) generateMain() (string, error) {
	f, err := os.CreateTemp(filepath.Dir(g.OutputName), "yamly-bootstrap")
	if err != nil {
		return "", err
	}

	fmt.Fprintln(f, "//go:build yamly")
	fmt.Fprintln(f)
	fmt.Fprintln(f, "// TEMPORARY AUTOGENERATED FILE: yamly bootstrap code to ")
	fmt.Fprintln(f, "// launch the actual generator")
	fmt.Fprintln(f)
	fmt.Fprintln(f, "package main")
	fmt.Fprintln(f)

	fmt.Fprintln(f, "import (")
	fmt.Fprintln(f, "  \"fmt\"")
	fmt.Fprintln(f, "  \"os\"")
	fmt.Fprintln(f)
	fmt.Fprintf(f, " generator %q\n", generatorPackage)
	fmt.Fprintln(f)
	fmt.Fprintf(f, " engine %q\n", g.EngineGeneratorPackage)
	fmt.Fprintln(f)
	fmt.Fprintf(f, "  pkg %q\n", g.PkgPath)
	fmt.Fprintln(f, ")")

	fmt.Fprintln(f, "func main() {")
	fmt.Fprintf(f, "  g := generator.New(%q)\n", filepath.Base(g.OutputName))
	fmt.Fprintf(f, "  g.SetPkgName(%q)\n", g.PkgName)
	fmt.Fprintf(f, "  g.SetPkgPath(%q)\n", g.PkgPath)
	fmt.Fprintf(f, "  g.SetEngineGenerator(engine."+g.EngineGenerator+")\n")
	if g.BuildTags != "" {
		fmt.Fprintf(f, "  g.SetBuildTags(%q)\n", g.BuildTags)
	}
	fmt.Fprintf(f, "  g.SetOmitempty(%t)\n", g.Omitempty)
	fmt.Fprintf(f, "  g.SetDisallowUnknownFields(%t)\n", g.DisallowUnknownFields)
	fmt.Fprintf(f, "  g.SetEncodePointerReceiver(%t)\n", g.EncodePointerReceiver)
	fmt.Fprintf(f, "  g.SetInlineEmbedded(%t)\n", g.InlineEmbedded)
	fmt.Fprintf(f, "  g.AddType(pkg.Exporter_yamly_%s(nil))\n", g.Type)

	fmt.Fprintln(f, "  if err := g.Generate(os.Stdout); err != nil {")
	fmt.Fprintln(f, "    fmt.Fprintln(os.Stderr, err)")
	fmt.Fprintln(f, "    os.Exit(1)")
	fmt.Fprintln(f, "  }")
	fmt.Fprintln(f, "}")

	src := f.Name()
	if err := f.Close(); err != nil {
		return src, err
	}

	dst := src + ".go"
	return dst, os.Rename(src, dst)
}

func (g *Generator) Generate() error {
	if err := g.generateStub(); err != nil {
		return fmt.Errorf("failed to generate stub: %w", err)
	}

	path, err := g.generateMain()
	if err != nil {
		return fmt.Errorf("failed to create main generator: %w", err)
	}
	defer os.Remove(path)

	f, err := os.Create(g.OutputName + ".tmp")
	if err != nil {
		return err
	}
	defer os.Remove(f.Name()) // will remain after rename

	cmd := exec.Command("go", "run", "-tags", g.BuildTags, filepath.Base(path)) // nolint: gosec

	cmd.Stdout = f
	cmd.Stderr = os.Stderr
	cmd.Dir = filepath.Dir(path)
	if err = cmd.Run(); err != nil {
		return fmt.Errorf("failed to run main generator: %w", err)
	}
	f.Close()

	data, err := os.ReadFile(f.Name())
	if err != nil {
		return err
	}

	formatedData, err := format.Source(data)
	if err != nil {
		fmt.Println(string(data))
		return fmt.Errorf("failed to format: %w", err)
	}
	return os.WriteFile(g.OutputName, formatedData, 0o600)
}
